<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>IgcFlyMap</title>
    <!-- <script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>
    <link href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css" rel="stylesheet"> -->
    <script src="/assets/cesium/Build/Cesium/Cesium.js"></script>
    <link href="/assets/cesium/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <link rel="stylesheet" href="./style2.css">
    <script src="https://kit.fontawesome.com/7e2e637b3b.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.2.1/dist/chart.umd.min.js"></script>
</head>

<body>
    <!-- Header -->
    <section id="header">
        <div class="header container">
            <div class="nav-bar">
                <div class="brand">
                    <a href="./index.html">
                        <h1><span>Igc</span><span class="span2"></span>Fly<span>Map</span><img src="./img/icon_logo.png"
                                class="logo_icon" alt="logo"></h1>
                    </a>
                </div>
                <div class="nav-list">
                    <div class="hamburger">
                        <div class="bar"></div>
                    </div>
                    <ul>
                        <li><a href="./index.html" data-after="Mapa">2D</a></li>
                        <li><a href="./testhtml.html" data-after="3D zobrazenie">3D</a></li>
                        <li>
                            <a id="about-link" data-lang-href-en="./about.html" data-lang-href-sk="./aboutsk.html">
                                <span data-lang="en" style="color: inherit;">About</span>
                                <span data-lang="sk" style="color: inherit;">O aplik치cii</span>
                            </a>
                        </li>

                        <button id="language-switcher_en">游섫릖<strong>ENG</strong></button>
                        <button id="language-switcher_sk">游젏릖<strong>SK</strong></button>
                    </ul>
                </div>
            </div>
        </div>
    </section>
    <!-- End Header -->
    <div class="container3D">
        <div id="cesiumContainer"></div>
        <div id="loading">
            <div class="spinner"></div>
            <div>
                <span data-lang="en">Loading your flight</span>
                <span data-lang="sk">Na캜칤tavanie letu</span>
            </div>
        </div>
        <div id="pilot-name" class="pilot-name"></div>
        <div id="altitude" class="altitude"></div>
        <div id="pilot-name"></div>
        <div id="horizontal-speed"></div>
        <div id="vertical-speed"></div>

        <div>
            <input type="file" id="file-input" onchange="parseFile(); changeId();" style="display:none;">
            <label for="file-input" id="play-button" class="tlacidlo" style="padding: 8px 20px; position: relative;">
                <span data-lang="en">Import file</span>
                <span data-lang="sk">Vlo쬴콘 s칰bor</span></label>
            <button class="tlacidlo" id="play-button" onclick="return false;" style=" position: relative; opacity: 0;">
                You need igc</button>
            <button class="savemap" id="play-animation"><i class="fa fa-play"></i>
                <span data-lang="en">Animation</span>
                <span data-lang="sk">Anim치cia letu</span></button>
            <button id="fastbutton" onclick="speedUp()"><i class="fa fa-forward"></i></button>
            <button id="slowbutton" onclick="slowDown()"><i class="fa fa-backward"></i></button>
        </div>
    </div>
    <div class="containerGraph">
        <canvas id="altitudeGraph"></canvas>
    </div>

</body>
<script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxNWRhMmYzMi03NzJmLTQzMWQtOTBjNC0xNDExZGVhOWRlZGEiLCJpZCI6MTI2MTY1LCJpYXQiOjE2NzcyMzgwMjV9.zVLhACU4c_P9pOaoDOOTPxb1ywhgiIL_rPS9SL54e8w';

    var viewer = new Cesium.Viewer('cesiumContainer', {
        infoBox: false,
        timeline: false,
        animation: false,
    });

    viewer.terrainProvider = Cesium.createWorldTerrain();

    // loading suborov - tocenie pri loadingu
    function changeId() {
        document.getElementById("loading").id = "loadingNone";
    }
    function removeLoading() {
        document.getElementById("loadingNone").id = "loading";
    }

    // zly format suboru
    function IGCException(message) {
        'use strict';

        this.message = message;
        this.name = "IGCException";
    }

    var parsedFlight = null;

    function parseFile() {
        'use strict';

        var fileInput = document.getElementById('file-input');
        var file = fileInput.files[0];
        var reader = new FileReader();

        reader.onload = function (e) {
            try {
                var igcFile = e.target.result;
                parsedFlight = parseIGC(igcFile); // Update parsedFlight here
                calculateSpeed(parsedFlight);
                console.log(parsedFlight);

                showTrack(parsedFlight);
                renderAltitudeGraph(parsedFlight);
                console.log(parsedFlight.latLong);


                document.getElementById('play-animation').onclick = function () {
                    playAnimation(parsedFlight);
                };

            } catch (error) {
                console.log(error);
            }
        };
        reader.onerror = function (e) {
            console.log(e);
        };
        reader.readAsText(file);
    }
    function parseIGC(igcFile) {
        'use strict';

        function parseManufacturer(aRecord) {
            var manufacturers = {
                'GCS': 'Garrecht',
                'CAM': 'Cambridge Aero Instruments',
                'DSX': 'Data Swan',
                'EWA': 'EW Avionics',
                'FIL': 'Filser',
                'FLA': 'FLARM',
                'SCH': 'Scheffel',
                'ACT': 'Aircotec',
                'NKL': 'Nielsen Kellerman',
                'LXN': 'LX Navigation',
                'IMI': 'IMI Gliding Equipment',
                'NTE': 'New Technologies s.r.l.',
                'PES': 'Peschges',
                'PRT': 'Print Technik',
                'SDI': 'Streamline Data Instruments',
                'TRI': 'Triadis Engineering GmbH',
                'LXV': 'LXNAV d.o.o.',
                'WES': 'Westerboer',
                'XCS': 'XCSoar',
                'ZAN': 'Zander'
            };

            var manufacturerInfo = {
                manufacturer: 'Unknown',
                serial: aRecord.substring(4, 7)
            };

            var manufacturerCode = aRecord.substring(1, 4);
            if (manufacturers[manufacturerCode]) {
                manufacturerInfo.manufacturer = manufacturers[manufacturerCode];
            }

            return manufacturerInfo;
        }

        function extractDate(igcFile) {
            var dateRecord = igcFile.match(/H[FO]DTE(?:DATE:)?(\d{2})(\d{2})(\d{2}),?(\d{2})?/);
            if (dateRecord === null) {
                throw new IGCException('The file does not contain a date header.');
            }

            var day = parseInt(dateRecord[1], 10);
            var month = parseInt(dateRecord[2], 10) - 1;
            var year = parseInt(dateRecord[3], 10);

            if (year < 80) {
                year += 2000;
            } else {
                year += 1900;
            }
            return new Date(Date.UTC(year, month, day));
        }

        function parseHeader(headerRecord) {
            var headerSubtypes = {
                'PLT': 'Pilot',
                'CM2': 'Crew member 2',
                'GTY': 'Glider type',
                'GID': 'Glider ID',
                'DTM': 'GPS Datum',
                'RFW': 'Firmware version',
                'RHW': 'Hardware version',
                'FTY': 'Flight recorder type',
                'GPS': 'GPS',
                'PRS': 'Pressure sensor',
                'FRS': 'Security suspect, use validation program',
                'CID': 'Competition ID',
                'CCL': 'Competition class'
            };

            var headerName = headerSubtypes[headerRecord.substring(2, 5)];
            if (headerName !== undefined) {
                var colonIndex = headerRecord.indexOf(':');
                if (colonIndex !== -1) {
                    var headerValue = headerRecord.substring(colonIndex + 1);
                    if (headerValue.length > 0 && /([^\s]+)/.test(headerValue)) {
                        return {
                            name: headerName,
                            value: headerValue
                        };
                    }
                }
            }
        }
        function parseLatLong(latLongString) {
            var latitude = parseFloat(latLongString.substring(0, 2)) +
                parseFloat(latLongString.substring(2, 7)) / 60000.0;
            if (latLongString.charAt(7) === 'S') {
                latitude = -latitude;
            }

            var longitude = parseFloat(latLongString.substring(8, 11)) +
                parseFloat(latLongString.substring(11, 16)) / 60000.0;
            if (latLongString.charAt(16) === 'W') {
                longitude = -longitude;
            }

            return [latitude, longitude];
        }

        function parsePosition(positionRecord, model, flightDate) {
            var positionRegex = /^B([\d]{2})([\d]{2})([\d]{2})([\d]{7}[NS][\d]{8}[EW])([AV])([-\d][\d]{4})([-\d][\d]{4})/;
            var positionMatch = positionRecord.match(positionRegex);
            if (positionMatch) {

                var positionTime = new Date(flightDate.getTime());
                positionTime.setUTCHours(parseInt(positionMatch[1], 10), parseInt(positionMatch[2], 10), parseInt(positionMatch[3], 10));

                if (model.recordTime.length > 0 &&
                    model.recordTime[0] > positionTime) {
                    positionTime.setDate(flightDate.getDate() + 1);
                }
                var curPosition = parseLatLong(positionMatch[4]);
                if ((curPosition[0] !== 0) && (curPosition[1] !== 0)) {
                    return {
                        recordTime: positionTime,
                        latLong: curPosition,
                        pressureAltitude: parseInt(positionMatch[6], 10),
                        gpsAltitude: parseInt(positionMatch[7], 10)
                    };
                }
            }
        }

        var invalidFileMessage = 'This is not IGC file';
        var igcLines = igcFile.split('\n');
        if (igcLines.length < 2) {
            throw new IGCException(invalidFileMessage);
        }


        var model = {
            headers: [],
            recordTime: [],
            latLong: [],
            pressureAltitude: [],
            gpsAltitude: [],
            taskpoints: []
        };

        if (!(/^A[\w]{6}/).test(igcLines[0])) {
            throw new IGCException(invalidFileMessage);
        }

        var manufacturerInfo = parseManufacturer(igcLines[0]);
        model.headers.push({
            name: 'Logger manufacturer',
            value: manufacturerInfo.manufacturer
        });

        model.headers.push({
            name: 'Logger serial number',
            value: manufacturerInfo.serial
        });

        var flightDate = extractDate(igcFile);
        var lineIndex;
        var positionData;
        var recordType;
        var currentLine;
        var headerData;

        for (lineIndex = 0; lineIndex < igcLines.length; lineIndex++) {
            currentLine = igcLines[lineIndex];
            recordType = currentLine.charAt(0);
            switch (recordType) {
                case 'B': // Position fix
                    positionData = parsePosition(currentLine, model, flightDate);
                    if (positionData) {
                        model.recordTime.push(positionData.recordTime);
                        model.latLong.push(positionData.latLong);
                        model.pressureAltitude.push(positionData.pressureAltitude);
                        model.gpsAltitude.push(positionData.gpsAltitude);
                    }
                    break;

                case 'C':
                    var taskRegex = /^C[\d]{7}[NS][\d]{8}[EW].*/;
                    if (taskRegex.test(currentLine)) {
                        model.taskpoints.push(currentLine.substring(1).trim());
                    }
                    break;

                case 'H':
                    headerData = parseHeader(currentLine);
                    if (headerData) {
                        model.headers.push(headerData);
                    }
                    break;
            }
        }
        return model;

    }


    function showTrack(parsedFlight) {
        var positions = parsedFlight.latLong.map((latLong, index) => {
            var altitude = parsedFlight.gpsAltitude[index];
            return Cesium.Cartesian3.fromDegrees(latLong[1], latLong[0], altitude);
        });

        var polyline = viewer.entities.add({
            polyline: {
                positions: positions,
                width: 3,
                material: Cesium.Color.fromCssColorString('rgb(230, 108, 32)'),
            },
        });

        var flightPath = parsedFlight.latLong;

        var startPoint = viewer.entities.add({
            position: positions[0],
            point: {
                pixelSize: 10,
                color: Cesium.Color.GREEN,
            },
        });

        var endPoint = viewer.entities.add({
            position: positions[positions.length - 1],
            billboard: {
                image: '/assets/finish.png', // Add your image url here
                width: 32, // These numbers are just placeholders
                height: 32, // Adjust as needed for your specific icon
            },
        });


        var track = {
            polyline: polyline,
            startPoint: startPoint,
            endPoint: endPoint,
        };
        var altitudeIndex = 0; // index na trackovanie current v칳코ky
        var altitudeDisplay = document.getElementById("altitude");

        var pilotName = parsedFlight.headers.find(header => header.name === "Pilot");
        var gliderName = parsedFlight.headers.find(header => header.name === "Glider type");
        if (pilotName && gliderName) {
            document.getElementById("pilot-name").innerText = "Pilot: " + pilotName.value + "\nGlider: " + gliderName.value;
            // Show the initial altitude
            altitudeDisplay.innerText = "Altitude: " + parsedFlight.gpsAltitude[altitudeIndex] + " m";
        }
        console.log("all good");
        console.log("Flight headers:", parsedFlight.headers);

        // priblizenie na track
        viewer.zoomTo([track.polyline, track.startPoint, track.endPoint]).then(function () {
            removeLoading();
        });
    }

    //graf
    function renderAltitudeGraph(parsedFlight) {
        const altitudeCanvas = document.getElementById('altitudeGraph');
        altitudeCanvas.style.backgroundColor = '#29323c';

        const altitudeData = parsedFlight.gpsAltitude;
        const timeData = parsedFlight.recordTime.map(time => time.toISOString().substr(11, 8));

        new Chart(altitudeCanvas, {
            type: 'line',
            data: {
                labels: timeData,
                datasets: [
                    {
                        label: 'Altitude',
                        data: altitudeData,
                        borderColor: 'rgb(230, 108, 32)', // Orange
                        backgroundColor: 'rgba(230, 108, 32, 0.1)', // Orange with transparency
                        borderWidth: 1,
                    },
                ],
            },
            options: {
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Time',
                        },
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Altitude (m)',
                        },
                    },
                },
            },
        });
    }

    // animacia letu
    var timerId;
    var isPlaying = false;
    var currentPositionIndex = 0;
    var movingDot = null;
    var interval = 100; // 코tartovacia r칳chlos콘

    function playAnimation(parsedFlight) {
        var flightPath = parsedFlight.latLong;
        var totalPositions = flightPath.length;
        var button = document.getElementById('play-animation');

        if (isPlaying) {
            clearTimeout(timerId);
            isPlaying = false;
            button.innerText = 'Play';
            return;
        }

        if (!movingDot) {
            movingDot = viewer.entities.add({
                position: Cesium.Cartesian3.fromDegrees(flightPath[currentPositionIndex][1], flightPath[currentPositionIndex][0], parsedFlight.gpsAltitude[currentPositionIndex]),
                billboard: {
                    image: '/assets/glider.png', // Add your image url here
                    // image: '/img/glider.png', // Add your image url here
                    width: 32, // These numbers are just placeholders
                    height: 32, // Adjust as needed for your specific icon
                },
            });
        }
        var horizontalSpeedDisplay = document.getElementById("horizontal-speed");
        var verticalSpeedDisplay = document.getElementById("vertical-speed");
        var altitudeDisplay = document.getElementById("altitude");

        function updateDotPosition() {
            if (currentPositionIndex >= totalPositions) {
                clearTimeout(timerId);
                isPlaying = false;
                button.innerText = 'Play';
                return;
            }
            var horizontalSpeed = parsedFlight.horizontalSpeeds[currentPositionIndex];
            var verticalSpeed = parsedFlight.verticalSpeeds[currentPositionIndex];
            var latLong = flightPath[currentPositionIndex];
            var altitude = parsedFlight.gpsAltitude[currentPositionIndex];
            movingDot.position = Cesium.Cartesian3.fromDegrees(latLong[1], latLong[0], altitude);

            // Update the altitude display
            altitudeDisplay.innerText = "Altitude: " + altitude + " m";
            horizontalSpeedDisplay.innerText = "Horizontal Speed: " + horizontalSpeed.toFixed(2) + " km/h";
            verticalSpeedDisplay.innerText = "Vertical Speed: " + verticalSpeed.toFixed(2) + " km/h";
            currentPositionIndex++;
            timerId = setTimeout(updateDotPosition, interval); // rekurzivne volanie funkcie
        }

        // Start the animation
        updateDotPosition();
        isPlaying = true;
        button.innerText = 'Pause';
    }

    function speedUp() {
        interval /= 4;
    }

    function slowDown() {
        interval *= 4;
    }

    // jazyk
    let currentLang = 'sk'; // Default language

    switchLanguage(currentLang);
    document.getElementById('language-switcher_en').addEventListener('click', function () {
        switchLanguage('en');
    });

    document.getElementById('language-switcher_sk').addEventListener('click', function () {
        switchLanguage('sk');
    });

    function switchLanguage(lang) {
        let elements = document.querySelectorAll('[data-lang]');
        elements.forEach(function (element) {
            if (element.getAttribute('data-lang') == lang) {
                element.style.display = 'inline';
            } else {
                element.style.display = 'none';
            }
        });

        // Switch the href for the about link
        let aboutLink = document.getElementById('about-link');
        aboutLink.href = aboutLink.getAttribute('data-lang-href-' + lang);

        currentLang = lang; // Update the current language
    }

    function calculateSpeed(model) {
        model.horizontalSpeeds = [];
        model.verticalSpeeds = [];
        var earthRadius = 6371;  // Radius of the Earth in kilometers

        for (var i = 1; i < model.recordTime.length; i++) {
            var prevLatLong = model.latLong[i - 1];
            var currLatLong = model.latLong[i];

            // Use Haversine formula to calculate the distance between two points on the sphere
            var dLat = (currLatLong[0] - prevLatLong[0]) * Math.PI / 180;
            var dLon = (currLatLong[1] - prevLatLong[1]) * Math.PI / 180;
            var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(prevLatLong[0] * Math.PI / 180) * Math.cos(currLatLong[0] * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            var distance = earthRadius * c;  // Distance in kilometers

            var deltaTime = (model.recordTime[i] - model.recordTime[i - 1]) / 1000;  // Time difference in seconds
            var horizontalSpeed = distance / deltaTime * 3600;  // Speed in km/h

            var prevAltitude = model.pressureAltitude[i - 1];
            var currAltitude = model.pressureAltitude[i];
            var verticalSpeed = (currAltitude - prevAltitude) / deltaTime * 3.6;  // Speed in km/h

            model.horizontalSpeeds.push(horizontalSpeed);
            model.verticalSpeeds.push(verticalSpeed);
        }
    }
</script>

</html>